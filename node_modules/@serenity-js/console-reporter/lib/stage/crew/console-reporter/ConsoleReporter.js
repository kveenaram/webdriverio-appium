"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConsoleReporter = void 0;
const lib_1 = require("@serenity-js/core/lib");
const events_1 = require("@serenity-js/core/lib/events");
const model_1 = require("@serenity-js/core/lib/model");
const chalk_1 = require("chalk");
const tiny_types_1 = require("tiny-types");
const Printer_1 = require("./Printer");
const Summary_1 = require("./Summary");
const SummaryFormatter_1 = require("./SummaryFormatter");
const themes_1 = require("./themes");
/**
 * @desc
 *  Uses [standard output](https://en.wikipedia.org/wiki/Standard_streams)
 *  to report on progress of your Serenity/JS acceptance tests.
 *
 *  `ConsoleReporter` ships with colour themes for both dark and light terminals,
 *  as well as a monochromatic theme for those moments when you're in a noir mood
 *  (or have a terminal that doesn't support colours, like the good old `cmd.exe` on Windows).
 *
 * @example <caption>Registering the reporter programmatically</caption>
 *  import { configure } from '@serenity-js/core';
 *  import { ConsoleReporter } from '@serenity-js/console-reporter';
 *
 *  configure({
 *      crew: [ ConsoleReporter.withDefaultColourSupport() ],
 *  });
 *
 * @example <caption>Registering the reporter using Protractor configuration</caption>
 *  // protractor.conf.js
 *  const { ConsoleReporter } = require('@serenity-js/console-reporter');
 *
 *  exports.config = {
 *    framework:     'custom',
 *    frameworkPath: require.resolve('@serenity-js/protractor/adapter'),
 *
 *    serenity: {
 *      crew: [
 *        ConsoleReporter.withDefaultColourSupport(),
 *      ],
 *      // other Serenity/JS config
 *    },
 *
 *    // other Protractor config
 *  };
 *
 * @public
 * @implements {@serenity-js/core/lib/stage~StageCrewMember}
 */
class ConsoleReporter {
    /**
     * @param {Printer} printer
     * @param {TerminalTheme} theme
     * @param {@serenity-js/core/lib/stage~Stage} [stage=null]
     */
    constructor(printer, theme, stage = null) {
        this.printer = printer;
        this.theme = theme;
        this.stage = stage;
        this.startTimes = new StartTimes();
        this.artifacts = new ActivityRelatedArtifacts();
        this.summary = new Summary_1.Summary();
        this.firstError = new FirstError();
        tiny_types_1.ensure('printer', printer, tiny_types_1.isDefined());
        tiny_types_1.ensure('theme', theme, tiny_types_1.isDefined());
        this.summaryFormatter = new SummaryFormatter_1.SummaryFormatter(this.theme);
    }
    /**
     * @desc
     *  Instantiates a `ConsoleReporter` that auto-detects
     *  your terminal's support for colours and use a colour theme
     *  for dark terminals if successful.
     *
     *  Please note that spawning your test process from another process
     *  (by using [npm-failsafe](https://www.npmjs.com/package/npm-failsafe), for example)
     *  causes the `ConsoleReporter` to use the monochromatic colour scheme,
     *  as colour support can't be detected in child processes.
     *
     *  If the above describes your setup, use {@link ConsoleReporter#forDarkTerminals}
     *  or {@link ConsoleReporter#forLightTerminals} to make the sub-process produce colour output.
     *
     * @returns {ConsoleReporter}
     */
    static withDefaultColourSupport() {
        return new ConsoleReporter(new Printer_1.Printer(process.stdout), new themes_1.ThemeForDarkTerminals(new chalk_1.Instance( /* auto-detect */)));
    }
    /**
     * @desc
     *  Instantiates a `ConsoleReporter` with a monochromatic colour theme.
     *  Good for terminals with no colour support (like the `cmd.exe` on Windows),
     *  or for when you need to pipe the output to a text file and want
     *  to avoid printing control characters.
     *
     * @returns {ConsoleReporter}
     */
    static forMonochromaticTerminals() {
        return new ConsoleReporter(new Printer_1.Printer(process.stdout), new themes_1.ThemeForMonochromaticTerminals());
    }
    /**
     * @desc
     *  Instantiates a `ConsoleReporter` with a colour theme optimised for terminals with dark backgrounds.
     *
     * @returns {ConsoleReporter}
     */
    static forDarkTerminals() {
        return new ConsoleReporter(new Printer_1.Printer(process.stdout), new themes_1.ThemeForDarkTerminals(new chalk_1.Instance({ level: 2 })));
    }
    /**
     * @desc
     *  Instantiates a `ConsoleReporter` with a colour theme optimised for terminals with light backgrounds.
     *
     * @returns {ConsoleReporter}
     */
    static forLightTerminals() {
        return new ConsoleReporter(new Printer_1.Printer(process.stdout), new themes_1.ThemeForLightTerminals(new chalk_1.Instance({ level: 2 })));
    }
    /**
     * @desc
     *  Creates a new instance of this {@link @serenity-js/core/lib/stage~StageCrewMember}
     *  and assigns it to a given {@link @serenity-js/core/lib/stage~Stage}.
     *
     * @see {@link @serenity-js/core/lib/stage~StageCrewMember}
     *
     * @param {@serenity-js/core/lib/stage~Stage} stage - An instance of a {@link @serenity-js/core/lib/stage~Stage} this {@link @serenity-js/core/lib/stage~StageCrewMember} will be assigned to
     * @returns {@serenity-js/core/lib/stage~StageCrewMember} - A new instance of this {@link @serenity-js/core/lib/stage~StageCrewMember}
     */
    assignedTo(stage) {
        return new ConsoleReporter(this.printer, this.theme, stage);
    }
    /**
     * @desc
     *  Handles {@link @serenity-js/core/lib/events~DomainEvent} objects emitted by the {@link @serenity-js/core/lib/stage~StageCrewMember}.
     *
     * @see {@link @serenity-js/core/lib/stage~StageCrewMember}
     *
     * @listens {@serenity-js/core/lib/events~DomainEvent}
     *
     * @param {@serenity-js/core/lib/events~DomainEvent} event
     * @returns {void}
     */
    notifyOf(event) {
        tiny_types_1.match(event)
            .when(events_1.SceneStarts, (e) => {
            this.firstError = new FirstError();
            this.startTimes.recordStartOf(e);
            // Print scenario header
            this.printer.println(this.theme.separator('-'));
            this.printer.println(e.details.location.path.value, e.details.location.line ? `:${e.details.location.line}` : '');
            this.printer.println();
            this.printer.println(this.theme.heading(e.details.category.value, ': ', e.details.name.value));
            this.printer.println();
        })
            // todo: add SceneTagged ...
            .when(events_1.TaskStarts, (e) => {
            this.printer.indent();
            if (!this.firstError.alreadyRecorded()) {
                this.printer.println(e.details.name.value);
            }
        })
            .when(events_1.InteractionStarts, (e) => {
            this.startTimes.recordStartOf(e);
        })
            .when(events_1.InteractionFinished, (e) => {
            this.printer.indent();
            this.printer.println(this.formattedOutcome(e));
            this.printer.indent();
            if (e.outcome instanceof model_1.ProblemIndication) {
                this.firstError.recordIfNeeded(e.outcome.error);
                if (!(e.outcome.error instanceof lib_1.AssertionError)) {
                    this.printer.println(this.theme.outcome(e.outcome, `${e.outcome.error}`));
                }
            }
            const artifacts = this.artifacts.recordedFor(e.activityId);
            if (artifacts.filter(a => a instanceof model_1.AssertionReport || a instanceof model_1.LogEntry).length > 0) {
                this.printer.println();
            }
            artifacts.forEach(evt => {
                if (evt.artifact instanceof model_1.AssertionReport) {
                    const details = evt.artifact.map((artifactContents) => this.theme.diff(artifactContents.expected, artifactContents.actual));
                    this.printer.println();
                    this.printer.println(details);
                    this.printer.println();
                }
                if (evt.artifact instanceof model_1.LogEntry) {
                    const details = evt.artifact.map((artifactContents) => artifactContents.data);
                    if (evt.name.value !== details) {
                        this.printer.println(this.theme.log(evt.name.value, ':'));
                    }
                    this.printer.println(details);
                    this.printer.println();
                }
            });
            this.printer.outdent();
            this.printer.outdent();
        })
            .when(events_1.ActivityRelatedArtifactGenerated, (e) => {
            this.artifacts.record(e);
        })
            .when(events_1.TaskFinished, (e) => {
            this.printer.outdent();
            if (e.outcome instanceof model_1.ProblemIndication) {
                this.printer.indent();
                this.printer.indent();
                if (!this.firstError.alreadyRecorded()) {
                    this.printer.println(this.theme.outcome(e.outcome, this.iconFrom(e.outcome), `${e.outcome.error}`));
                }
                this.printer.outdent();
                this.printer.outdent();
                this.firstError.recordIfNeeded(e.outcome.error);
            }
            else if (!(e.outcome instanceof model_1.ExecutionSuccessful)) {
                this.printer.indent();
                this.printer.println(this.iconFrom(e.outcome), e.details.name.value);
                this.printer.outdent();
            }
        })
            .when(events_1.SceneFinished, (e) => {
            var _a;
            this.summary.record(e.details, e.outcome, this.startTimes.eventDurationOf(e));
            this.printer.println();
            this.printer.println(this.theme.outcome(e.outcome, this.formattedOutcome(e, this.deCamelCased(e.outcome.constructor.name))));
            if (e.outcome instanceof model_1.ProblemIndication) {
                this.printer.println();
                this.printer.indent();
                if (e.outcome instanceof model_1.ImplementationPending) {
                    this.printer.println(`${e.outcome.error.name}: ${e.outcome.error.message}`);
                }
                else if ((_a = e.outcome.error) === null || _a === void 0 ? void 0 : _a.stack) {
                    this.printer.println(e.outcome.error.stack);
                }
                this.printer.outdent();
            }
            this.artifacts.clear();
        })
            .when(events_1.TestRunFinished, (e) => {
            this.printer.println(this.theme.separator('='));
            this.printer.print(this.summaryFormatter.format(this.summary.aggregated()));
            this.printer.println(this.theme.separator('='));
        })
            .else((e) => {
            return void 0;
        });
    }
    formattedOutcome(event, description = event.details.name.value) {
        const icon = `${this.iconFrom(event.outcome)}`, message = `${description} (${this.startTimes.eventDurationOf(event)})`;
        return (event.outcome instanceof model_1.ProblemIndication)
            ? this.theme.outcome(event.outcome, `${icon}${message}`)
            : `${this.theme.outcome(event.outcome, icon)}${message}`;
    }
    deCamelCased(name) {
        const deCamelCased = name.replace(/([^A-Z])([A-Z])/g, '$1 $2');
        return deCamelCased.charAt(0).toUpperCase() + deCamelCased.slice(1).toLocaleLowerCase();
    }
    iconFrom(outcome) {
        switch (outcome.constructor) {
            case model_1.ExecutionCompromised:
            case model_1.ExecutionFailedWithError:
            case model_1.ExecutionFailedWithAssertionError:
                return '✗ ';
            case model_1.ImplementationPending:
                return '☕';
            case model_1.ExecutionSkipped:
                return '⇢ ';
            case model_1.ExecutionIgnored:
                return '? ';
            case model_1.ExecutionSuccessful:
                return '✓ ';
            default:
                return '';
        }
    }
}
exports.ConsoleReporter = ConsoleReporter;
class StartTimes {
    constructor() {
        this.times = {};
    }
    recordStartOf(event) {
        this.times[event.details.toString()] = event.timestamp;
    }
    eventDurationOf(event) {
        return event.timestamp.diff(this.times[event.details.toString()]);
    }
}
class FirstError {
    recordIfNeeded(error) {
        if (!this.error) {
            this.error = error;
        }
    }
    alreadyRecorded() {
        return !!this.error;
    }
    get() {
        return this.error;
    }
}
class ActivityRelatedArtifacts {
    constructor() {
        this.events = [];
    }
    record(event) {
        this.events.push(event);
    }
    recordedFor(activityId) {
        return this.events
            .filter(event => event.activityId.equals(activityId));
    }
    clear() {
        this.events = [];
    }
}
//# sourceMappingURL=ConsoleReporter.js.map